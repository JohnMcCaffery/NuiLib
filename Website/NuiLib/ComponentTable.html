<table>
	<tr>
		<td>Name</td><td>Access</td><td>Description</td><td>Arguments</td>
	</tr> 
	<tr>
		<td colspan="4"><center>Scalars</center></td>
	</tr> 
	<tr>
		<td>Sum</td>
		<td><i>op1</i> + <i>op2</i></td>
		<td>Arithmetic Sum</td>
		<td><i>op1</i>(Scalar/float), <i>op2</i>(Scalar/float)</td>
	</tr>
	<tr>
		<td>Difference</td>
		<td><i>op1</i> - <i>op2</i></td>
		<td>Arithmetic Difference</td>
		<td><i>op1</i>(Scalar/float), <i>op2</i>(Scalar/float)</td>
	</tr>
	<tr>
		<td>Product</td>
		<td><i>op1</i> * <i>op2</i></td>
		<td>Arithmetic Product</td>
		<td><i>op1</i>(Scalar/float), <i>op2</i>(Scalar/float)</td>
	</tr>
	<tr>
		<td>Quotient</td>
		<td><i>op1</i> / <i>op2</i></td>
		<td>Arithmetic Quotient</td>
		<td><i>op1</i>(Scalar/float), <i>op2</i>(Scalar/float)</td>
	</tr>
	<tr>
		<td>Sum equals</td>
		<td><i>op1</i> += <i>op2</i></td>
		<td>Arithmetic Sum then Store in <i>op1</i></td>
		<td><i>op1</i>(Scalar/float), <i>op2</i>(Scalar/float)</td>
	</tr>
	<tr>
		<td>Difference equals</td>
		<td><i>op1</i> -= <i>op2</i></td>
		<td>Arithmetic Difference then Store in <i>op1</i></td>
		<td><i>op1</i>(Scalar/float), <i>op2</i>(Scalar/float)</td>
	</tr>
	<tr>
		<td>Product equals</td>
		<td><i>op1</i> *= <i>op2</i></td>
		<td>Arithmetic Product then Store in <i>op1</i></td>
		<td><i>op1</i>(Scalar/float), <i>op2</i>(Scalar/float)</td>
	</tr>
	<tr>
		<td>Quotient equals</td>
		<td><i>op1</i> /= <i>op2</i></td>
		<td>Arithmetic Quotient then Store in <i>op1</i></td>
		<td><i>op1</i>(Scalar/float), <i>op2</i>(Scalar/float)</td>
	</tr>
	<tr>
		<td>X component</td>
		<td>x(<i>vector</i></i>)</td>
		<td>The x component of a Vector</td>
		<td><i>vector</i>(Vector)</td>
	</tr>
	<tr>
		<td>Y component</td>
		<td>y(<i>vector</i>)</td>
		<td>The y component of a Vector</td>
		<td><i>vector</i>(Vector)</td>
	</tr>
	<tr>
		<td>Z component</td>
		<td>z(<i>vector</i>)</td>
		<td>The z component of a Vector</td>
		<td><i>vector</i>(Vector)</td>
	</tr>
	<tr>
		<td>Magnitude</td>
		<td>magnitude(<i>vector</i>)</td>
		<td>The magnitude of a Vector</td>
		<td><i>vector</i>(Vector)</td>
	</tr>
	<tr>
		<td>Dot</td>
		<td>dot(<i>a</i>, <i>b</i>)</td>
		<td>The dot product of two Vectors.</td>
		<td><i>a</i>(Vector), <i>b</i>(Vector)</td>
	</tr>
	<tr>
		<td>Normalize Max</td>
		<td>normalize(<i>input</i>)</td>
		<td>Normalize a scalar against the maximum value it has ever been</td>
		<td><i>input</i>(Scalar)</td>
	</tr>
	<tr>
		<td>Constrain</td>
		<td>constrain(<i>input</i>, <i>deadzone</i>, <i>range</i>, <i>grace</i>, <i>mirror</i>)</td>
		<td>Constrain an input to between 0 and 1. Constraining is done based on a specific range between deadzone and deadzone + range. Less than deadzone = 0. Deadzone to Deadzone + Range = 0 to 1. Deadzone+Range to Deadzone+Range+Grace = 1. More than Deadzone+Range+Grace = 0. Input can be mirrored (absolute values used so that negative values are constrained in an inverse of positive values) or not.</td>
		<td><i>input</i>(Scalar), <i>deadzone</i>(Scalar/float), <i>range</i>(Scalar/float), <i>grace</i>(Scalar/float), <i>mirror</i>(bool)</td>
	</tr>
	<tr>
		<td>Absolute Value</td>
		<td>abs(<i>input</i>)</td>
		<td>Take the absolute value of a scalar.</td>
		<td><i>input</i>(Scalar)</td>
	</tr>
	<tr>
		<td>Invert</td>
		<td>invert(<i>condition</i>)</td>
		<td>Invert based on a condition. If the condition is true, value is -1, otherwise value is 1.</td>
		<td><i>condition</i>(Condition)</td>
	</tr>
	<tr>
		<td>Delta</td>
		<td>delta(<i>input</i>)</td>
		<td>The change in a scalar between the last value and the current value.</td>
		<td><i>input</i>(Scalar)</td>
	</tr>
	<tr>
		<td>Project</td>
		<td>project(<i>a</i>, <i>b</i>)</td>
		<td>The scalar projection of vector a onto vector b onto another.</td>
		<td><i>a</i>(Vector), <i>b</i>(Vector)</td>
	</tr>
	<tr>
		<td>If</td>
		<td>ifscalar(<i>condition</i>, <i>t</i>, <i>f</i>)</td>
		<td>Value = condition ? t : f.</td>
		<td><i>condition</i>(Condition), <i>t</i>(Scalar/float), <i>f</i>(Scalar/float)</td>
	</tr>
	<tr>
		<td>Tracker</td>
		<td>tracker(<i>title</i>, <i>max</i>, <i>scale</i>, <i>shift</i>, <i>value</i>)</td>
		<td>Display a window with a tracker bar whose position translates into the value of the scalar. Raw tracker values are between 0 and max. Final value is (raw * scale) + shift. Initial value is value.</td>
		<td><i>title</i>(string), <i>max</i>(int), <i>scale</i>(float), <i>shift</i>(float), <i>value</i>(int)</td>
	</tr>
	<tr>
		<td colspan="4"><center>Vectors</center></td>
	</tr>
	<tr>
		<td>Sum</td>
		<td><i>op1</i> + <i>op2</i></td>
		<td>Arithmetic Sum. Value = (<i>op1</i>.x + <i>op2</i>.x, <i>op1</i>.y + <i>op2</i>.y, <i>op1</i>.z + <i>op2</i>.z)</td>
		<td><i>op1</i>(Vector/Point3f/float), <i>op2</i>(Vector/Point3f/float)</td>
	</tr>
	<tr>
		<td>Difference</td>
		<td><i>op1</i> - <i>op2</i></td>
		<td>Arithmetic Sum. Value = (<i>op1</i>.x - <i>op2</i>.x, <i>op1</i>.y - <i>op2</i>.y, <i>op1</i>.z - <i>op2</i>.z)</td>
		<td><i>op1</i>(Vector/Point3f/float), <i>op2</i>(Vector/Point3f/float)</td>
	</tr>
	<tr>
		<td>Product</td>
		<td><i>op1</i> * <i>op2</i></td>
		<td>Arithmetic Sum. Value = (<i>op1</i>.x * <i>op2</i>.x, <i>op1</i>.y * <i>op2</i>.y, <i>op1</i>.z * <i>op2</i>.z)</td>
		<td><i>op1</i>(Vector/Point3f/float), <i>op2</i>(Vector/Point3f/float)</td>
	</tr>
	<tr>
		<td>Quotient</td>
		<td><i>op1</i> / <i>op2</i></td>
		<td>Arithmetic Sum. Value = (<i>op1</i>.x / <i>op2</i>.x, <i>op1</i>.y / <i>op2</i>.y, <i>op1</i>.z / <i>op2</i>.z)</td>
		<td><i>op1</i>(Vector/Point3f/float), <i>op2</i>(Vector/Point3f/float)</td>
	</tr>
	<tr>
		<td>Sum equals</td>
		<td><i>op1</i> += <i>op2</i></td>
		<td>Arithmetic Sum then Store in <i>op1</i>. Value = (<i>op1</i>.x + <i>op2</i>.x, <i>op1</i>.y + <i>op2</i>.y, <i>op1</i>.z + <i>op2</i>.z)</td>
		<td><i>op1</i>(Vector), <i>op2</i>(Vector/Point3f/float)</td>
	</tr>
	<tr>
		<td>Difference equals</td>
		<td><i>op1</i> -= <i>op2</i></td>
		<td>Arithmetic Sum then Store in <i>op1</i>. Value = (<i>op1</i>.x - <i>op2</i>.x, <i>op1</i>.y - <i>op2</i>.y, <i>op1</i>.z - <i>op2</i>.z)</td>
		<td><i>op1</i>(Vector), <i>op2</i>(Vector/Point3f/float)</td>
	</tr>
	<tr>
		<td>Product equals</td>
		<td><i>op1</i> *= <i>op2</i></td>
		<td>Arithmetic Sum then Store in <i>op1</i>. Value = (<i>op1</i>.x * <i>op2</i>.x, <i>op1</i>.y * <i>op2</i>.y, <i>op1</i>.z * <i>op2</i>.z)</td>
		<td><i>op1</i>(Vector), <i>op2</i>(Vector/Point3f/float)</td>
	</tr>
	<tr>
		<td>Quotient equals</td>
		<td><i>op1</i> /= <i>op2</i></td>
		<td>Arithmetic Sum then Store in <i>op1</i>. Value = (<i>op1</i>.x / <i>op2</i>.x, <i>op1</i>.y / <i>op2</i>.y, <i>op1</i>.z / <i>op2</i>.z)</td>
		<td><i>op1</i>(Vector), <i>op2</i>(Vector/Point3f/float)</td>
	</tr>
	<tr>
		<td>Normalize Max</td>
		<td>normalize(<i>input</i>)</td>
		<td>Normalize a vector so its magnitude is 1.</td>
		<td><i>input</i>(Vector)</td>
	</tr>
	<tr>
		<td>Cross Product</td>
		<td>cross(<i>a</i>, <i>b</i>)</td>
		<td>The cross product of two vectors.</td>
		<td><i>a</i>(Vector), <i>b</i>(Vector)</td>
	</tr>
	<tr>
		<td>Limit</td>
		<td>limit(<i>vector</i>, <i>x</i>, <i>y</i>, <i>z</i>)</td>
		<td>Limit a vector to only chosen axes. Non-chosen axes are 0. Set x, y or z true to select that axis.</td>
		<td><i>vector</i>(Vector), <i>x</i>(bool), <i>y</i>(bool), <i>z</i>(bool)</td>
	</tr>
	<tr>
		<td>Delta</td>
		<td>delta(<i>input</i>)</td>
		<td>The change in each component of a vector between the last value and the current value.</td>
		<td><i>input</i>(Vector)</td>
	</tr>
	<tr>
		<td>Snapshot</td>
		<td>snapshot(<i>vector</i>, <i>condition</i>)</td>
		<td>Take a snapshot of a vector every time a condition becomes true.</td>
		<td><i>vector</i>(Vector), <i>condition</i>(Condition)</td>
	</tr>
	<tr>
		<td>Momentum</td>
		<td>momentum(<i>vector</i>, <i>condition</i>, <i>decrement</i>, <i>threshold</i>)</td>
		<td>As long as condition is true value is vector. As soon as the condition becomes false the final delta is used to calculate momentum. It is shifted so that it's magnitude reduces by decrement each threshold until it is less than threshold.</td>
		<td><i>vector</i>(Vector), <i>condition</i>(Condition), <i>decrement</i>(float), <i>threshold</i>(float)</td>
	</tr>
	<tr>
		<td>Scale</td>
		<td>scale(<i>vector</i>, <i>scale</i>)</td>
		<td>Scale a vector so it's magnitude is scale.</td>
		<td><i>vector</<i>i></i>(Vector), <i>scale</i>(Scalar/float)</td>
	</tr>
	<tr>
		<td>Intersect</td>
		<td>intersect(<i>pPlane</i>, <i>normalPlane</i>, <i>pLine</i>, <i>dirLine</i>)</td>
		<td>Calculate the intersection of a point and a plane. Pplane is a point on the plane. NormalPlane is the normal to the plane. Pline is a point on the line. DirLine is the direction of the line.</td>
		<td><i>pPlane</i>(Vector), <i>normalPlane</i>(Vector), <i>pLine</i>(Vector), <i>dirLine</i>(Vector)</td>
	</tr>
	<tr>
		<td>Joint</td>
		<td>joint(<i>joint</i>)</td>
		<td>Get the 3D cartesian coordinates of a skeleton point in space.</td>
		<td><i>joint</i>(int)</td>
	</tr>
	<tr>
		<td colspan="4"><center>Conditions</center></td>
	</tr>
	<tr>
		<td>Greater</td>
		<td><i>op1</i> &gt; <i>op2</i> </td>
		<td>True if <i>op1</i> is greater than <i>op2</i></td>
		<td><i>op1</i>(Scalar/float), <i>op2</i>(Scalar/float)</td>
	</tr>
	<tr>
		<td>Less</td>
		<td><i>op1</i> &lt; <i>op2</i> </td>
		<td>True if <i>op1</i> is less than <i>op2</i></td>
		<td><i>op1</i>(Scalar/float), <i>op2</i>(Scalar/float)</td>
	</tr>
	<tr>
		<td>Greater Equal</td>
		<td><i>op1</i> &#8805; <i>op2</i> </td>
		<td>True if <i>op1</i> is greater or equal to <i>op2</i></td>
		<td><i>op1</i>(Scalar/float), <i>op2</i>(Scalar/float)</td>
	</tr>
	<tr>
		<td>Less Equal</td>
		<td><i>op1</i> &#8804; <i>op2</i> </td>
		<td>True if <i>op1</i> is less or equal to <i>op2</i></td>
		<td><i>op1</i>(Scalar/float), <i>op2</i>(Scalar/float)</td>
	</tr>
	<tr>
		<td>Equal To</td>
		<td><i>op1</i> == <i>op2</i></td>
		<td>True if <i>op1</i> is equal to <i>op2</i></td>
		<td><i>op1</i>(Scalar/float), <i>op2</i>(Scalar/float)</td>
	</tr>
	<tr>
		<td>Not Equal To</td>
		<td><i>op1</i> != <i>op2</i></td>
		<td>True if <i>op1</i> is not equal to <i>op2</i></td>
		<td><i>op1</i>(Scalar/Point3f/float), <i>op2</i>(Scalar/Point3f/float)</td>
	</tr>
	<tr>
		<td>And</td>
		<td><i>op1</i> && <i>op2</i></td>
		<td>True if <i>op1</i> and <i>op2</i> are true</td>
		<td><i>op1</i>(Condition/bool), <i>op2</i>(Condition/bool)</td>
	</tr>
	<tr>
		<td>Or</td>
		<td><i>op1</i> || <i>op2</i></td>
		<td>True if <i>op1</i> or <i>op2</i> is true</td>
		<td><i>op1</i>(Condition/bool), <i>op2</i>(Condition/bool)</td>
	</tr>
	<tr>

		<td>Fist</td>
		<td>fist(<i>rightHand</i>)</td>
		<td>True if the specified hand is in a fist. Righthand = true: specify right hand. Righthand = false. Specify left hand.</td>
		<td><i>rightHand</i>(bool)</td>
	</tr>
</table>
