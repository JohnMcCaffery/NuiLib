NuiLib is a utility library intended to ease integration of NUI (Natural User Input) Devices (such as the Microsoft Kinect) into applications. The abstraction layer hides the device being input from and provides easy support for common operations. Applications built using NUI lib benefit from the ability to make the logic of how the device is used clear and easy to understand. They also gain the ability to switch to different driver sets or even different devices just by changing which libraries are linked.

The following code snippet is an example of NuiLib's ease of use. It demonstrates initialising the device, gaining access to the location information for two skeleton joints and then computing the vector between the two joints and then outputing this vector whenever the values change.
<code>
	#include <a href="http://www.cs.st-andrews.ac.uk/~johnmcc/Documentation/_nui_lib-_a_p_i_8h_source.html">&lt;NuiLib-API.h&gt;</a>
	using namespace NuiLib;
	...
	NuiFactory()-&gt;Init();
	Vector arm = joint(HAND_RIGHT) - joint(SHOULDER_RIGHT);
	arm.AddListener([&arm](IObservable *s) { cout &lt;&lt; "Right Arm: " &lt;&lt; arm.X() &lt;&lt; ',' &lt;&lt; arm.Y() &lt;&lt; ',' &lt;&lt; arm.Z() &lt;&lt; '\n'; });
	NuiFactory()-&gt;SetAutoPoll(true);
	...
</code>

The syntax makes it very clear what is happening. There is an extension mechanism so any device capable of providing cartesian coordinates for skeleton joints could be integrated. Advanced functionality can also be added. An example of this is that the library supplies fist detection using the thresholding algorithm described <a href="">here</a> and implemented in <a href="">this</a> example.


By providing a simplified abstraction layer over NUI device inputs programmers can focus on the maths and the logic associated with integrating a NuiDevice into an application rather than the bookkeeping necessary to get the input in the first place. The abstraction layer also makes it easy to swap out different devices or different drivers for the same device for cross compatibility. 

NuiLib has three target audiences. Firstly, those who want to integrate NUI input into their applications. Secondly, those developing new algorithms and mechanisms for parsing NUI input who wish that work to plug in easily to existing systems. Thirdly, those interested in optimising NUI input across a range of pre-existing projects.

NuiLib is built to have two 'faces'. The public face and the extendability face. Those who just wish to integrate NUI support into their application use the public face. This is comprised of a single header file, <i><a href="http://www.cs.st-andrews.ac.uk/~johnmcc/Documentation/_nui_lib-_a_p_i_8h_source.html">&lt;NuiLib-API.h&gt;</a></i>. This gives access to the core functionality. With this users can get access to cartesian coordinates of skeleton joints in 3D space.

The private face allows extensibility. By referencing the extensibility header (<i><a href="http://www.cs.st-andrews.ac.uk/~johnmcc/Documentation/_nui_lib-_extendable_8h_source.html">&lt;NuiLib-Extendable.h&gt;</a></i>) advanced users can start to add their own functionality.

The main building blocks of NuiLib are NUIFactories, Components and Component Factory Functions. NUIFactories are classes that actually interact with the NUI device. They are singleton objects. Different NuiFactory implementations support different devices / driver sets. They are built and linked seperately. Components are what the user programs with (they can be either Scalars, Vectors or Conditions). Component Factory Functions are functions that are used to create Components.

When working NuiLib the basic work flow is to initialise the NuiFactory instance, call some Component Factory Functions to get the raw inputs and then use a series of Component Factory Functions to produced the required output.

Components are what drive the system. They are built to auto updated and to chain. This means that once you have a Vector that is tied to a specfic joint in the user's skeleton if the, NUI device picks up that that joint has moved the Vector will be updated. It will also trigger an event notifying any Components that rely on it that it has been updated. These dependant Components can then also update.

For example, say you have Vector H and Scalar X. H represents the position of the right hand. Scalar X is the x component of Vector H. As soon as H is updated by the NUI device it will change its value and trigger an event. X is listening for this event and, when it sees it has been triggered, will update its own value. Thus, if the final output you are aiming for is the X coordinate of the user's right hand, all that is necessary is to store the X Scalar. This stored value can then be queried at each iteration of the main loop (or alternatively whenever the Scalar raises an event to say it has changed something can happen).

The syntax for all this is kept deliberately simple. Creating H is as simple as <code>Vector H = joint(HAND_RIGHT);</code>. X is <code>Scalar X = x(H);</code>. Accessing the value of X is <code>cout &lt;&lt; *X;</code>.
